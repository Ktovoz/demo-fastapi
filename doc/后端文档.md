# 后端文档

<!-- 
文档管理规范:
- 内容：包含后端技术栈和具体实现细节
- 目的：详细记录后端开发所使用的技术、框架及具体实现方式
请AI在编辑此文档时遵守上述规范
-->

## 技术栈

### Web框架
- **FastAPI 0.104.1** - 现代、快速的Web框架，支持自动API文档生成
- **Uvicorn 0.24.0[standard]** - ASGI服务器，支持HTTP/2和WebSocket

### 数据库和ORM
- **SQLite** - 轻量级文件数据库，适合开发和小型部署
- **SQLAlchemy** - Python SQL工具包和对象关系映射(ORM)
- **Alembic** - 数据库迁移工具

### 数据验证和序列化
- **Pydantic 2.5.0** - 数据验证和序列化库，支持类型注解

### 身份认证和安全
- **python-jose[cryptography] 3.3.0** - JWT Token处理
- **passlib[bcrypt] 1.7.4** - 密码哈希和验证
- **python-multipart 0.0.6** - 文件上传支持

### 配置和环境
- **python-dotenv 1.0.0** - 环境变量管理
- **Pydantic Settings** - 配置管理

### 日志和监控
- **Loguru 0.7.2** - 简洁高效的日志库
- **内置结构化日志支持**

### HTTP客户端
- **httpx 0.25.2** - 异步HTTP客户端

### 开发工具
- **pytest** - 测试框架
- **black** - 代码格式化
- **isort** - 导入排序
- **mypy** - 类型检查

## 项目结构

```
backend/
├── app/
│   ├── core/                   # 核心配置模块
│   │   ├── __init__.py
│   │   ├── config.py           # 应用配置
│   │   ├── security.py         # 安全相关配置
│   │   └── database.py         # 数据库配置
│   ├── models/                 # 数据模型
│   │   ├── __init__.py
│   │   ├── base.py             # 基础模型类
│   │   ├── user.py             # 用户模型
│   │   ├── role.py             # 角色模型
│   │   ├── permission.py       # 权限模型
│   │   └── operation_log.py    # 操作日志模型
│   ├── schemas/                # Pydantic数据模式
│   │   ├── __init__.py
│   │   ├── base.py             # 基础模式
│   │   ├── user.py             # 用户模式
│   │   ├── auth.py             # 认证模式
│   │   ├── role.py             # 角色模式
│   │   └── common.py           # 通用模式
│   ├── routers/                # API路由
│   │   ├── __init__.py
│   │   ├── auth.py             # 认证路由
│   │   ├── users.py            # 用户管理路由
│   │   ├── roles.py            # 角色管理路由
│   │   ├── dashboard.py        # 仪表板路由
│   │   └── system.py           # 系统管理路由
│   ├── services/               # 业务逻辑层
│   │   ├── __init__.py
│   │   ├── user_service.py     # 用户服务
│   │   ├── auth_service.py     # 认证服务
│   │   ├── role_service.py     # 角色服务
│   │   └── system_service.py   # 系统服务
│   ├── utils/                  # 工具模块
│   │   ├── __init__.py
│   │   ├── logger.py           # 日志工具
│   │   ├── dependencies.py     # 依赖注入
│   │   ├── security.py         # 安全工具
│   │   └── decorators.py       # 装饰器
│   └── main.py                 # 应用入口
├── alembic/                    # 数据库迁移
│   ├── versions/               # 迁移版本
│   ├── env.py                  # 迁移环境
│   └── alembic.ini             # 迁移配置
├── data/                       # 数据库文件目录
├── tests/                      # 测试文件
│   ├── __init__.py
│   ├── conftest.py             # 测试配置
│   ├── test_auth.py            # 认证测试
│   ├── test_users.py           # 用户测试
│   └── test_utils.py           # 工具测试
├── .env.example                # 环境变量示例
├── .gitignore                  # Git忽略文件
├── requirements.txt            # Python依赖
├── requirements-dev.txt        # 开发依赖
├── pyproject.toml              # 项目配置
├── alembic.ini                 # Alembic配置
├── pytest.ini                 # 测试配置
└── run.py                      # 运行脚本
```

## 实现细节

### 核心配置模块

#### 1. 应用配置 (core/config.py)
```python
from pydantic_settings import BaseSettings
from typing import Optional
import secrets

class Settings(BaseSettings):
    # 应用基础配置
    APP_NAME: str = "后台管理Demo系统"
    APP_VERSION: str = "1.0.0"
    DEBUG: bool = False

    # 服务器配置
    HOST: str = "0.0.0.0"
    PORT: int = 8000

    # 安全配置
    SECRET_KEY: str = secrets.token_urlsafe(32)
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    REFRESH_TOKEN_EXPIRE_MINUTES: int = 7 * 24 * 60  # 7天

    # 数据库配置
    DATABASE_URL: str = "sqlite:///./data/app.db"

    # 日志配置
    LOG_LEVEL: str = "INFO"
    LOG_FILE: str = "logs/app.log"
    LOG_ROTATION: str = "10 MB"
    LOG_RETENTION: str = "7 days"

    # CORS配置
    BACKEND_CORS_ORIGINS: list[str] = [
        "http://localhost:3000",
        "http://localhost:5173",
        "http://127.0.0.1:3000",
    ]

    # 用户配置
    DEFAULT_ADMIN_USERNAME: str = "admin"
    DEFAULT_ADMIN_PASSWORD: str = "admin123"
    DEFAULT_ADMIN_EMAIL: str = "admin@example.com"

    # 分页配置
    DEFAULT_PAGE_SIZE: int = 10
    MAX_PAGE_SIZE: int = 100

    class Config:
        env_file = ".env"
        case_sensitive = True

# 创建全局配置实例
settings = Settings()
```

#### 2. 数据库配置 (core/database.py)
```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session
from sqlalchemy.pool import StaticPool
from typing import Generator
import os

from .config import settings
from ..utils.logger import get_logger

logger = get_logger(__name__)

# 创建数据库引擎
engine = create_engine(
    settings.DATABASE_URL,
    connect_args={
        "check_same_thread": False,  # SQLite特有配置
    },
    poolclass=StaticPool,  # SQLite使用静态连接池
    echo=settings.DEBUG  # 开发模式下打印SQL语句
)

# 创建会话工厂
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# 创建基础模型类
Base = declarative_base()

def get_db() -> Generator[Session, None, None]:
    """获取数据库会话"""
    db = SessionLocal()
    try:
        yield db
    except Exception as e:
        logger.error(f"数据库会话错误: {e}")
        db.rollback()
        raise
    finally:
        db.close()

def init_db():
    """初始化数据库"""
    try:
        # 确保数据目录存在
        os.makedirs(os.path.dirname(settings.DATABASE_URL.replace("sqlite:///", "")), exist_ok=True)

        # 创建所有表
        Base.metadata.create_all(bind=engine)
        logger.info("数据库表创建成功")

        # 初始化默认数据
        from ..services.init_service import init_default_data
        init_default_data()

        logger.info("数据库初始化完成")
    except Exception as e:
        logger.error(f"数据库初始化失败: {e}")
        raise
```

### 数据模型定义

#### 1. 基础模型 (models/base.py)
```python
from sqlalchemy import Column, Integer, DateTime, Boolean
from sqlalchemy.sql import func
from typing import Any
from ..core.database import Base

class BaseModel(Base):
    """基础模型类"""
    __abstract__ = True

    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now(), comment="创建时间")
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), comment="更新时间")
    is_active = Column(Boolean, default=True, comment="是否启用")

    def to_dict(self) -> dict[str, Any]:
        """转换为字典"""
        return {
            column.name: getattr(self, column.name)
            for column in self.__table__.columns
        }

    def update_from_dict(self, data: dict[str, Any]) -> None:
        """从字典更新属性"""
        for key, value in data.items():
            if hasattr(self, key) and key not in ['id', 'created_at']:
                setattr(self, key, value)
```

#### 2. 用户模型 (models/user.py)
```python
from sqlalchemy import Column, String, DateTime, Boolean
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from typing import List

from .base import BaseModel

class User(BaseModel):
    """用户模型"""
    __tablename__ = "users"

    username = Column(String(50), unique=True, index=True, nullable=False, comment="用户名")
    email = Column(String(100), unique=True, index=True, nullable=False, comment="邮箱")
    password_hash = Column(String(255), nullable=False, comment="密码哈希")
    full_name = Column(String(100), comment="全名")
    avatar = Column(String(255), comment="头像URL")
    is_superuser = Column(Boolean, default=False, comment="是否超级用户")
    last_login = Column(DateTime(timezone=True), comment="最后登录时间")

    # 关系
    user_roles = relationship("UserRole", back_populates="user", cascade="all, delete-orphan")
    roles = relationship("Role", secondary="user_roles", back_populates="users")
    operation_logs = relationship("OperationLog", back_populates="user")

    def __repr__(self):
        return f"<User(username='{self.username}', email='{self.email}')>"

    def has_role(self, role_name: str) -> bool:
        """检查用户是否有指定角色"""
        return any(role.name == role_name for role in self.roles)

    def has_permission(self, permission_name: str) -> bool:
        """检查用户是否有指定权限"""
        for role in self.roles:
            for permission in role.permissions:
                if permission.name == permission_name:
                    return True
        return False

    def get_permissions(self) -> List[str]:
        """获取用户所有权限"""
        permissions = []
        for role in self.roles:
            permissions.extend([p.name for p in role.permissions])
        return list(set(permissions))
```

#### 3. 角色和权限模型 (models/role.py, models/permission.py)
```python
# models/role.py
from sqlalchemy import Column, String, Text, Boolean
from sqlalchemy.orm import relationship
from typing import List

from .base import BaseModel

class Role(BaseModel):
    """角色模型"""
    __tablename__ = "roles"

    name = Column(String(50), unique=True, index=True, nullable=False, comment="角色名称")
    description = Column(String(200), comment="角色描述")

    # 关系
    user_roles = relationship("UserRole", back_populates="role", cascade="all, delete-orphan")
    users = relationship("User", secondary="user_roles", back_populates="roles")
    role_permissions = relationship("RolePermission", back_populates="role", cascade="all, delete-orphan")
    permissions = relationship("Permission", secondary="role_permissions", back_populates="roles")

    def __repr__(self):
        return f"<Role(name='{self.name}', description='{self.description}')>"

# models/permission.py
from sqlalchemy import Column, String, Text
from sqlalchemy.orm import relationship

from .base import BaseModel

class Permission(BaseModel):
    """权限模型"""
    __tablename__ = "permissions"

    name = Column(String(100), unique=True, index=True, nullable=False, comment="权限名称")
    resource = Column(String(50), nullable=False, comment="资源名称")
    action = Column(String(50), nullable=False, comment="操作类型")
    description = Column(String(200), comment="权限描述")

    # 关系
    role_permissions = relationship("RolePermission", back_populates="permission", cascade="all, delete-orphan")
    roles = relationship("Role", secondary="role_permissions", back_populates="permissions")

    def __repr__(self):
        return f"<Permission(name='{self.name}', resource='{self.resource}', action='{self.action}')>"

# models/user_role.py (关联表)
from sqlalchemy import Column, Integer, ForeignKey
from sqlalchemy.orm import relationship

from .base import BaseModel

class UserRole(BaseModel):
    """用户角色关联表"""
    __tablename__ = "user_roles"

    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, comment="用户ID")
    role_id = Column(Integer, ForeignKey("roles.id"), nullable=False, comment="角色ID")

    # 关系
    user = relationship("User", back_populates="user_roles")
    role = relationship("Role", back_populates="user_roles")

    def __repr__(self):
        return f"<UserRole(user_id={self.user_id}, role_id={self.role_id})>"

# models/role_permission.py (关联表)
class RolePermission(BaseModel):
    """角色权限关联表"""
    __tablename__ = "role_permissions"

    role_id = Column(Integer, ForeignKey("roles.id"), nullable=False, comment="角色ID")
    permission_id = Column(Integer, ForeignKey("permissions.id"), nullable=False, comment="权限ID")

    # 关系
    role = relationship("Role", back_populates="role_permissions")
    permission = relationship("Permission", back_populates="role_permissions")

    def __repr__(self):
        return f"<RolePermission(role_id={self.role_id}, permission_id={self.permission_id})>"
```

### 数据模式定义

#### 1. 用户模式 (schemas/user.py)
```python
from pydantic import BaseModel, EmailStr, Field, validator
from typing import Optional, List
from datetime import datetime

from .base import BaseResponse, BasePaginationResponse

class UserBase(BaseModel):
    """用户基础模式"""
    username: str = Field(..., min_length=3, max_length=50, description="用户名")
    email: EmailStr = Field(..., description="邮箱")
    full_name: Optional[str] = Field(None, max_length=100, description="全名")
    avatar: Optional[str] = Field(None, description="头像URL")
    is_active: bool = Field(True, description="是否启用")

class UserCreate(UserBase):
    """创建用户模式"""
    password: str = Field(..., min_length=6, max_length=50, description="密码")
    role_ids: Optional[List[int]] = Field(default=[], description="角色ID列表")

    @validator('username')
    def validate_username(cls, v):
        if not v.isalnum() and '_' not in v:
            raise ValueError('用户名只能包含字母、数字和下划线')
        return v

    @validator('password')
    def validate_password(cls, v):
        if len(v) < 6:
            raise ValueError('密码长度不能少于6位')
        return v

class UserUpdate(BaseModel):
    """更新用户模式"""
    email: Optional[EmailStr] = Field(None, description="邮箱")
    full_name: Optional[str] = Field(None, max_length=100, description="全名")
    avatar: Optional[str] = Field(None, description="头像URL")
    is_active: Optional[bool] = Field(None, description="是否启用")
    role_ids: Optional[List[int]] = Field(None, description="角色ID列表")

class UserResponse(UserBase):
    """用户响应模式"""
    id: int
    is_superuser: bool
    last_login: Optional[datetime]
    created_at: datetime
    updated_at: datetime
    roles: List['RoleResponse'] = Field(default=[], description="用户角色")

    class Config:
        from_attributes = True

class UserLogin(BaseModel):
    """用户登录模式"""
    username: str = Field(..., description="用户名或邮箱")
    password: str = Field(..., description="密码")

class UserChangePassword(BaseModel):
    """修改密码模式"""
    old_password: str = Field(..., description="旧密码")
    new_password: str = Field(..., min_length=6, max_length=50, description="新密码")

class UserListResponse(BasePaginationResponse):
    """用户列表响应模式"""
    items: List[UserResponse] = Field(..., description="用户列表")

# 避免循环导入，在文件底部定义
from .role import RoleResponse
UserResponse.model_rebuild()
```

#### 2. 认证模式 (schemas/auth.py)
```python
from pydantic import BaseModel, Field
from typing import Optional, List

class Token(BaseModel):
    """Token模式"""
    access_token: str = Field(..., description="访问令牌")
    refresh_token: str = Field(..., description="刷新令牌")
    token_type: str = Field("bearer", description="令牌类型")
    expires_in: int = Field(..., description="过期时间(秒)")

class TokenData(BaseModel):
    """Token数据模式"""
    user_id: Optional[int] = None
    username: Optional[str] = None
    permissions: List[str] = Field(default=[], description="用户权限")
    roles: List[str] = Field(default=[], description="用户角色")

class LoginResponse(BaseModel):
    """登录响应模式"""
    token: Token = Field(..., description="令牌信息")
    user: 'UserResponse' = Field(..., description="用户信息")

    class Config:
        from_attributes = True

class RefreshTokenRequest(BaseModel):
    """刷新Token请求模式"""
    refresh_token: str = Field(..., description="刷新令牌")

# 避免循环导入
from .user import UserResponse
LoginResponse.model_rebuild()
```

### 业务逻辑服务

#### 1. 用户服务 (services/user_service.py)
```python
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_
from typing import Optional, List, Dict, Any
from datetime import datetime

from ..models.user import User
from ..models.role import Role
from ..schemas.user import UserCreate, UserUpdate
from ..core.security import get_password_hash, verify_password
from ..utils.logger import get_logger
from .auth_service import get_user_permissions

logger = get_logger(__name__)

class UserService:
    """用户服务类"""

    def __init__(self, db: Session):
        self.db = db

    def get_user_by_id(self, user_id: int) -> Optional[User]:
        """根据ID获取用户"""
        try:
            user = self.db.query(User).filter(User.id == user_id).first()
            if user:
                logger.debug(f"获取用户成功: {user.username}")
            return user
        except Exception as e:
            logger.error(f"获取用户失败: {e}")
            return None

    def get_user_by_username(self, username: str) -> Optional[User]:
        """根据用户名获取用户"""
        try:
            user = self.db.query(User).filter(
                or_(User.username == username, User.email == username)
            ).first()
            if user:
                logger.debug(f"根据用户名获取用户成功: {username}")
            return user
        except Exception as e:
            logger.error(f"根据用户名获取用户失败: {e}")
            return None

    def get_users(
        self,
        skip: int = 0,
        limit: int = 10,
        username: Optional[str] = None,
        email: Optional[str] = None,
        is_active: Optional[bool] = None
    ) -> tuple[List[User], int]:
        """获取用户列表"""
        try:
            query = self.db.query(User)

            # 构建过滤条件
            if username:
                query = query.filter(User.username.contains(username))
            if email:
                query = query.filter(User.email.contains(email))
            if is_active is not None:
                query = query.filter(User.is_active == is_active)

            # 获取总数
            total = query.count()

            # 分页查询
            users = query.offset(skip).limit(limit).all()

            logger.info(f"获取用户列表成功: {len(users)}条记录")
            return users, total
        except Exception as e:
            logger.error(f"获取用户列表失败: {e}")
            return [], 0

    def create_user(self, user_data: UserCreate) -> Optional[User]:
        """创建用户"""
        try:
            # 检查用户名和邮箱是否已存在
            existing_user = self.db.query(User).filter(
                or_(User.username == user_data.username, User.email == user_data.email)
            ).first()

            if existing_user:
                if existing_user.username == user_data.username:
                    raise ValueError("用户名已存在")
                else:
                    raise ValueError("邮箱已存在")

            # 创建用户
            user = User(
                username=user_data.username,
                email=user_data.email,
                password_hash=get_password_hash(user_data.password),
                full_name=user_data.full_name,
                avatar=user_data.avatar,
                is_active=user_data.is_active
            )

            self.db.add(user)
            self.db.commit()
            self.db.refresh(user)

            # 分配角色
            if user_data.role_ids:
                roles = self.db.query(Role).filter(Role.id.in_(user_data.role_ids)).all()
                user.roles = roles
                self.db.commit()

            logger.info(f"创建用户成功: {user.username}")
            return user
        except Exception as e:
            self.db.rollback()
            logger.error(f"创建用户失败: {e}")
            raise

    def update_user(self, user_id: int, user_data: UserUpdate) -> Optional[User]:
        """更新用户"""
        try:
            user = self.get_user_by_id(user_id)
            if not user:
                return None

            # 检查邮箱是否重复
            if user_data.email and user_data.email != user.email:
                existing_user = self.db.query(User).filter(
                    and_(User.email == user_data.email, User.id != user_id)
                ).first()
                if existing_user:
                    raise ValueError("邮箱已存在")

            # 更新用户信息
            update_data = user_data.dict(exclude_unset=True)
            role_ids = update_data.pop('role_ids', None)

            for field, value in update_data.items():
                setattr(user, field, value)

            user.updated_at = datetime.utcnow()

            # 更新角色
            if role_ids is not None:
                roles = self.db.query(Role).filter(Role.id.in_(role_ids)).all()
                user.roles = roles

            self.db.commit()
            self.db.refresh(user)

            logger.info(f"更新用户成功: {user.username}")
            return user
        except Exception as e:
            self.db.rollback()
            logger.error(f"更新用户失败: {e}")
            raise

    def delete_user(self, user_id: int) -> bool:
        """删除用户"""
        try:
            user = self.get_user_by_id(user_id)
            if not user:
                return False

            # 软删除
            user.is_active = False
            user.updated_at = datetime.utcnow()

            self.db.commit()

            logger.info(f"删除用户成功: {user.username}")
            return True
        except Exception as e:
            self.db.rollback()
            logger.error(f"删除用户失败: {e}")
            return False

    def change_password(self, user_id: int, old_password: str, new_password: str) -> bool:
        """修改密码"""
        try:
            user = self.get_user_by_id(user_id)
            if not user:
                return False

            # 验证旧密码
            if not verify_password(old_password, user.password_hash):
                raise ValueError("原密码不正确")

            # 更新密码
            user.password_hash = get_password_hash(new_password)
            user.updated_at = datetime.utcnow()

            self.db.commit()

            logger.info(f"修改密码成功: {user.username}")
            return True
        except Exception as e:
            self.db.rollback()
            logger.error(f"修改密码失败: {e}")
            raise

    def update_last_login(self, user_id: int) -> bool:
        """更新最后登录时间"""
        try:
            user = self.get_user_by_id(user_id)
            if not user:
                return False

            user.last_login = datetime.utcnow()
            self.db.commit()

            return True
        except Exception as e:
            logger.error(f"更新最后登录时间失败: {e}")
            return False
```

### API路由实现

#### 1. 认证路由 (routers/auth.py)
```python
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from datetime import timedelta

from ..core.database import get_db
from ..core.config import settings
from ..core.security import create_access_token, verify_token
from ..schemas.auth import Token, LoginResponse, RefreshTokenRequest
from ..schemas.user import UserResponse
from ..services.auth_service import authenticate_user, create_refresh_token_db
from ..services.user_service import UserService
from ..utils.logger import get_logger
from ..utils.dependencies import get_current_user

logger = get_logger(__name__)
router = APIRouter(prefix="/auth", tags=["认证"])

@router.post("/login", response_model=LoginResponse, summary="用户登录")
async def login(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db)
):
    """用户登录接口"""
    try:
        logger.info(f"用户登录尝试: {form_data.username}")

        # 验证用户
        user = authenticate_user(db, form_data.username, form_data.password)
        if not user:
            logger.warning(f"登录失败: 用户名或密码错误 - {form_data.username}")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="用户名或密码错误",
                headers={"WWW-Authenticate": "Bearer"},
            )

        if not user.is_active:
            logger.warning(f"登录失败: 用户已被禁用 - {form_data.username}")
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="用户账号已被禁用"
            )

        # 创建访问令牌
        access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": str(user.id), "username": user.username},
            expires_delta=access_token_expires
        )

        # 创建刷新令牌
        refresh_token = create_refresh_token_db(db, user.id)

        # 更新最后登录时间
        user_service = UserService(db)
        user_service.update_last_login(user.id)

        logger.info(f"用户登录成功: {user.username}")

        return LoginResponse(
            token=Token(
                access_token=access_token,
                refresh_token=refresh_token,
                token_type="bearer",
                expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60
            ),
            user=UserResponse.from_orm(user)
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"登录过程出错: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="登录失败，请稍后重试"
        )

@router.post("/refresh", response_model=Token, summary="刷新令牌")
async def refresh_token(
    request: RefreshTokenRequest,
    db: Session = Depends(get_db)
):
    """刷新访问令牌"""
    try:
        # 验证刷新令牌
        user = verify_token(request.refresh_token, db, token_type="refresh")
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="无效的刷新令牌"
            )

        # 创建新的访问令牌
        access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": str(user.id), "username": user.username},
            expires_delta=access_token_expires
        )

        logger.info(f"令牌刷新成功: {user.username}")

        return Token(
            access_token=access_token,
            refresh_token=request.refresh_token,
            token_type="bearer",
            expires_in=settings.ACCESS_TOKEN_EXPIRE_MINUTES * 60
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"刷新令牌失败: {e}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="刷新令牌失败"
        )

@router.post("/logout", summary="用户登出")
async def logout(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """用户登出接口"""
    try:
        # TODO: 将刷新令牌加入黑名单
        logger.info(f"用户登出: {current_user.username}")
        return {"message": "登出成功"}
    except Exception as e:
        logger.error(f"登出失败: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="登出失败"
        )

@router.get("/me", response_model=UserResponse, summary="获取当前用户信息")
async def get_current_user_info(
    current_user: User = Depends(get_current_user)
):
    """获取当前登录用户信息"""
    return UserResponse.from_orm(current_user)
```

#### 2. 用户管理路由 (routers/users.py)
```python
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from typing import Optional

from ..core.database import get_db
from ..schemas.user import (
    UserResponse, UserCreate, UserUpdate, UserListResponse, UserChangePassword
)
from ..services.user_service import UserService
from ..utils.dependencies import get_current_user, require_permission
from ..utils.logger import get_logger
from ..models.user import User

logger = get_logger(__name__)
router = APIRouter(prefix="/users", tags=["用户管理"])

@router.get("/", response_model=UserListResponse, summary="获取用户列表")
async def get_users(
    page: int = Query(1, ge=1, description="页码"),
    size: int = Query(10, ge=1, le=100, description="每页数量"),
    username: Optional[str] = Query(None, description="用户名搜索"),
    email: Optional[str] = Query(None, description="邮箱搜索"),
    is_active: Optional[bool] = Query(None, description="是否启用"),
    db: Session = Depends(get_db),
    current_user: User = Depends(require_permission("user:read"))
):
    """获取用户列表"""
    try:
        user_service = UserService(db)
        skip = (page - 1) * size

        users, total = user_service.get_users(
            skip=skip,
            limit=size,
            username=username,
            email=email,
            is_active=is_active
        )

        return UserListResponse(
            items=[UserResponse.from_orm(user) for user in users],
            total=total,
            page=page,
            size=size
        )
    except Exception as e:
        logger.error(f"获取用户列表失败: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="获取用户列表失败"
        )

@router.get("/{user_id}", response_model=UserResponse, summary="获取用户详情")
async def get_user(
    user_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(require_permission("user:read"))
):
    """获取用户详情"""
    try:
        user_service = UserService(db)
        user = user_service.get_user_by_id(user_id)

        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="用户不存在"
            )

        return UserResponse.from_orm(user)
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"获取用户详情失败: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="获取用户详情失败"
        )

@router.post("/", response_model=UserResponse, summary="创建用户")
async def create_user(
    user_data: UserCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(require_permission("user:create"))
):
    """创建用户"""
    try:
        user_service = UserService(db)
        user = user_service.create_user(user_data)

        logger.info(f"创建用户成功: {user.username}")
        return UserResponse.from_orm(user)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        logger.error(f"创建用户失败: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="创建用户失败"
        )

@router.put("/{user_id}", response_model=UserResponse, summary="更新用户")
async def update_user(
    user_id: int,
    user_data: UserUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(require_permission("user:update"))
):
    """更新用户"""
    try:
        user_service = UserService(db)
        user = user_service.update_user(user_id, user_data)

        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="用户不存在"
            )

        logger.info(f"更新用户成功: {user.username}")
        return UserResponse.from_orm(user)
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        logger.error(f"更新用户失败: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="更新用户失败"
        )

@router.delete("/{user_id}", summary="删除用户")
async def delete_user(
    user_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(require_permission("user:delete"))
):
    """删除用户"""
    try:
        user_service = UserService(db)
        success = user_service.delete_user(user_id)

        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="用户不存在"
            )

        logger.info(f"删除用户成功: user_id={user_id}")
        return {"message": "用户删除成功"}
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"删除用户失败: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="删除用户失败"
        )

@router.post("/{user_id}/change-password", summary="修改密码")
async def change_password(
    user_id: int,
    password_data: UserChangePassword,
    db: Session = Depends(get_db),
    current_user: User = Depends(require_permission("user:update"))
):
    """修改用户密码"""
    try:
        # 检查权限：用户只能修改自己的密码，或者有管理权限
        if current_user.id != user_id and not current_user.is_superuser:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="权限不足"
            )

        user_service = UserService(db)
        success = user_service.change_password(
            user_id, password_data.old_password, password_data.new_password
        )

        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="用户不存在"
            )

        logger.info(f"修改密码成功: user_id={user_id}")
        return {"message": "密码修改成功"}
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"修改密码失败: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="修改密码失败"
        )
```

### 安全工具实现

#### 1. 密码和JWT处理 (core/security.py)
```python
from datetime import datetime, timedelta
from typing import Optional, Union, Any
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.orm import Session

from .config import settings
from ..models.user import User
from ..core.database import get_db
from ..utils.logger import get_logger

logger = get_logger(__name__)

# 密码加密上下文
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# OAuth2 scheme
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/auth/login")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """验证密码"""
    try:
        return pwd_context.verify(plain_password, hashed_password)
    except Exception as e:
        logger.error(f"密码验证失败: {e}")
        return False

def get_password_hash(password: str) -> str:
    """获取密码哈希"""
    try:
        return pwd_context.hash(password)
    except Exception as e:
        logger.error(f"密码哈希生成失败: {e}")
        raise

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """创建访问令牌"""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)

    to_encode.update({"exp": expire, "type": "access"})

    try:
        encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
        return encoded_jwt
    except Exception as e:
        logger.error(f"创建访问令牌失败: {e}")
        raise

def create_refresh_token(user_id: int, expires_delta: Optional[timedelta] = None) -> str:
    """创建刷新令牌"""
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.REFRESH_TOKEN_EXPIRE_MINUTES)

    to_encode = {
        "sub": str(user_id),
        "exp": expire,
        "type": "refresh"
    }

    try:
        encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
        return encoded_jwt
    except Exception as e:
        logger.error(f"创建刷新令牌失败: {e}")
        raise

def verify_token(token: str, db: Session, token_type: str = "access") -> Optional[User]:
    """验证令牌"""
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])

        # 检查令牌类型
        if payload.get("type") != token_type:
            logger.warning(f"令牌类型不匹配: 期望{token_type}, 实际{payload.get('type')}")
            return None

        user_id: str = payload.get("sub")
        if user_id is None:
            logger.warning("令牌中缺少用户ID")
            return None

        user = db.query(User).filter(User.id == int(user_id)).first()
        if user is None:
            logger.warning(f"用户不存在: {user_id}")
            return None

        if not user.is_active:
            logger.warning(f"用户已被禁用: {user_id}")
            return None

        return user
    except JWTError as e:
        logger.warning(f"令牌验证失败: {e}")
        return None
    except Exception as e:
        logger.error(f"令牌验证过程出错: {e}")
        return None

async def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: Session = Depends(get_db)
) -> User:
    """获取当前用户"""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="无法验证凭据",
        headers={"WWW-Authenticate": "Bearer"},
    )

    user = verify_token(token, db, "access")
    if user is None:
        raise credentials_exception

    return user
```

### 应用入口配置

#### 1. 主应用文件 (main.py)
```python
from fastapi import FastAPI, Request, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from contextlib import asynccontextmanager
import uvicorn

from .core.config import settings
from .core.database import init_db
from .utils.logger import get_logger
from .routers import auth, users, roles, dashboard, system

logger = get_logger(__name__)

@asynccontextmanager
async def lifespan(app: FastAPI):
    """应用生命周期管理"""
    # 启动时执行
    logger.info("🚀 后台管理系统启动中...")

    try:
        # 初始化数据库
        init_db()
        logger.info("✅ 数据库初始化完成")

        # 应用启动完成
        logger.info(f"🎉 {settings.APP_NAME} v{settings.APP_VERSION} 启动成功")
        logger.info(f"📡 服务运行在: http://{settings.HOST}:{settings.PORT}")
        logger.info(f"📚 API文档: http://{settings.HOST}:{settings.PORT}/docs")

    except Exception as e:
        logger.error(f"❌ 应用启动失败: {e}")
        raise

    yield

    # 关闭时执行
    logger.info("🛑 后台管理系统正在关闭...")

# 创建FastAPI应用
app = FastAPI(
    title=settings.APP_NAME,
    version=settings.APP_VERSION,
    description="基于FastAPI + Vue3的后台管理系统Demo",
    lifespan=lifespan,
    docs_url="/docs" if settings.DEBUG else None,
    redoc_url="/redoc" if settings.DEBUG else None
)

# CORS中间件
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.BACKEND_CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 全局异常处理
@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    """HTTP异常处理器"""
    logger.warning(f"HTTP异常: {exc.status_code} - {exc.detail} - {request.url}")
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "message": exc.detail,
            "status_code": exc.status_code,
            "path": str(request.url)
        }
    )

@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    """通用异常处理器"""
    logger.error(f"未处理的异常: {type(exc).__name__} - {str(exc)} - {request.url}")
    return JSONResponse(
        status_code=500,
        content={
            "message": "服务器内部错误" if not settings.DEBUG else str(exc),
            "status_code": 500,
            "path": str(request.url)
        }
    )

# 请求日志中间件
@app.middleware("http")
async def log_requests(request: Request, call_next):
    """请求日志中间件"""
    start_time = time.time()

    # 记录请求
    logger.info(f"📤 {request.method} {request.url}")

    response = await call_next(request)

    # 记录响应
    process_time = time.time() - start_time
    logger.info(f"📥 {request.method} {request.url} - {response.status_code} - {process_time:.3f}s")

    return response

# 注册路由
app.include_router(auth.router, prefix="/api")
app.include_router(users.router, prefix="/api")
app.include_router(roles.router, prefix="/api")
app.include_router(dashboard.router, prefix="/api")
app.include_router(system.router, prefix="/api")

# 根路径
@app.get("/")
async def root():
    """根路径"""
    return {
        "message": f"欢迎使用{settings.APP_NAME}",
        "version": settings.APP_VERSION,
        "docs": "/docs"
    }

# 健康检查
@app.get("/health")
async def health_check():
    """健康检查"""
    return {
        "status": "healthy",
        "version": settings.APP_VERSION,
        "timestamp": datetime.utcnow().isoformat()
    }

if __name__ == "__main__":
    uvicorn.run(
        "app.main:app",
        host=settings.HOST,
        port=settings.PORT,
        reload=settings.DEBUG,
        log_level="info"
    )
```

### 测试框架配置

#### 1. 测试配置 (tests/conftest.py)
```python
import pytest
import tempfile
import os
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from fastapi.testclient import TestClient

from app.main import app
from app.core.database import get_db, Base
from app.core.config import settings

# 创建临时数据库
@pytest.fixture(scope="session")
def test_db():
    """创建测试数据库"""
    # 创建临时文件
    db_fd, db_path = tempfile.mkstemp()

    test_database_url = f"sqlite:///{db_path}"

    # 创建测试引擎
    engine = create_engine(
        test_database_url,
        connect_args={"check_same_thread": False}
    )

    TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

    # 创建表
    Base.metadata.create_all(bind=engine)

    # 覆盖数据库依赖
    def override_get_db():
        try:
            db = TestingSessionLocal()
            yield db
        finally:
            db.close()

    app.dependency_overrides[get_db] = override_get_db

    yield TestingSessionLocal

    # 清理
    os.close(db_fd)
    os.unlink(db_path)

@pytest.fixture
def client(test_db):
    """创建测试客户端"""
    return TestClient(app)

@pytest.fixture
def test_user(test_db):
    """创建测试用户"""
    from app.services.user_service import UserService
    from app.schemas.user import UserCreate

    user_service = UserService(test_db)
    user_data = UserCreate(
        username="testuser",
        email="test@example.com",
        password="test123456",
        full_name="测试用户"
    )

    return user_service.create_user(user_data)

@pytest.fixture
def auth_headers(client, test_user):
    """获取认证头"""
    response = client.post("/api/auth/login", data={
        "username": "testuser",
        "password": "test123456"
    })

    token = response.json()["token"]["access_token"]
    return {"Authorization": f"Bearer {token}"}
```

### 部署配置

#### 1. 运行脚本 (run.py)
```python
import uvicorn
import os
import sys

# 添加项目根目录到Python路径
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from app.core.config import settings
from app.utils.logger import get_logger

logger = get_logger(__name__)

def main():
    """启动应用"""
    logger.info(f"正在启动 {settings.APP_NAME} v{settings.APP_VERSION}")

    try:
        uvicorn.run(
            "app.main:app",
            host=settings.HOST,
            port=settings.PORT,
            reload=settings.DEBUG,
            log_level=settings.LOG_LEVEL.lower(),
            access_log=True
        )
    except KeyboardInterrupt:
        logger.info("应用已停止")
    except Exception as e:
        logger.error(f"启动失败: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
```

### 开发规范

#### 1. 代码规范
- 使用Black进行代码格式化
- 使用isort进行导入排序
- 使用mypy进行类型检查
- 遵循PEP 8编码规范

#### 2. API设计规范
- RESTful API设计原则
- 统一的响应格式
- 完整的错误处理
- 详细的API文档

#### 3. 安全规范
- 输入数据验证
- SQL注入防护
- XSS攻击防护
- CSRF防护
- 权限验证

#### 4. 日志规范
- 结构化日志格式
- 分级日志记录
- 敏感信息脱敏
- 操作审计日志

#### 5. 测试规范
- 单元测试覆盖
- 集成测试
- API测试
- 测试数据管理